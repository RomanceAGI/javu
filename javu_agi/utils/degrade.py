import os, io, textwrap, time, json, subprocess, hashlib, pathlib
from typing import Optional, List
from PIL import Image, ImageDraw, ImageFont

IMG_CACHE = os.getenv("IMG_CACHE_DIR", "artifacts/img_cache")
TTS_CACHE = os.getenv("TTS_CACHE_DIR", "artifacts/tts_cache")
VIDEO_OUT = os.getenv("VIDEO_OUT_DIR", "artifacts/video_cache")
DEGRADE = os.getenv("DEGRADE_MODE", "soft").lower() == "soft"
QUEUE_ON = os.getenv("QUEUE_MODE", "on").lower() == "on"

pathlib.Path(IMG_CACHE).mkdir(parents=True, exist_ok=True)
pathlib.Path(TTS_CACHE).mkdir(parents=True, exist_ok=True)
pathlib.Path(VIDEO_OUT).mkdir(parents=True, exist_ok=True)

try:
    from redis import Redis

    _r = Redis.from_url(os.getenv("REDIS_URL", "redis://localhost:6379/0"))
    _r.ping()
except Exception:
    _r = None


def _sha(s: str) -> str:
    return hashlib.sha1(s.encode("utf-8")).hexdigest()


def text_image_stub(prompt: str, size: str = "1024x1024") -> str:
    """Fallback gambar: render prompt ke kanvas cantik. Selalu berhasil."""
    w, h = [int(x) for x in size.split("x")]
    out = os.path.join(IMG_CACHE, f"stub_{_sha(size+'|'+prompt)}.png")
    if os.path.exists(out):
        return out
    img = Image.new("RGB", (w, h), (18, 18, 20))
    draw = ImageDraw.Draw(img)
    try:
        font = ImageFont.truetype("DejaVuSans.ttf", 28)
    except Exception:
        # Fall back to the default bitmap font if the TTF font cannot be loaded.
        font = ImageFont.load_default()
    txt = textwrap.fill(prompt[:800], width=40)
    margin = 40
    draw.rectangle(
        [(margin - 10, margin - 10), (w - margin + 10, h - margin + 10)],
        outline=(90, 90, 95),
        width=4,
    )
    draw.multiline_text(
        (margin, margin), txt, fill=(230, 230, 235), font=font, spacing=6
    )
    # watermark kecil
    draw.text((w - 220, h - 40), "generated by AGI", fill=(120, 120, 125), font=font)
    img.save(out, "PNG")
    return out


def subtitles_from_text(text: str) -> str:
    """Fallback audio: bikin SRT dari teks. Selalu berhasil."""
    out = os.path.join(TTS_CACHE, f"stub_{_sha(text)}.srt")
    if os.path.exists(out):
        return out
    lines = [l for l in textwrap.wrap(text[:2000], width=50)]
    with open(out, "w", encoding="utf-8") as f:
        t0 = 0.0
        for i, ln in enumerate(lines, 1):
            t1 = t0 + max(2.0, len(ln) / 12.0)
            f.write(f"{i}\n")
            f.write(f"00:00:{int(t0):02d},000 --> 00:00:{int(t1):02d},000\n")
            f.write(ln + "\n\n")
            t0 = t1
    return out


def text_slideshow_video(
    text: str, frames: int = 8, fps: int = 6, size: str = "1024x1024"
) -> str:
    """Fallback video: pakai frame teks aja, stitched via ffmpeg. Selalu berhasil (butuh ffmpeg)."""
    out = os.path.join(VIDEO_OUT, f"stub_{_sha(text)}.mp4")
    if os.path.exists(out):
        return out
    # buat frames
    toks = textwrap.wrap(text[:2000], width=60)
    frames_path: List[str] = []
    for i in range(frames):
        snippet = toks[i % max(1, len(toks))]
        frame = text_image_stub(snippet, size=size)
        frames_path.append(frame)
    # list.txt untuk concat
    listp = os.path.join(VIDEO_OUT, f"{_sha('list|'+text)}.txt")
    with open(listp, "w", encoding="utf-8") as f:
        for fp in frames_path:
            f.write(f"file '{os.path.abspath(fp)}'\n")
    raw_mp4 = os.path.join(VIDEO_OUT, f"{_sha('raw|'+text)}.mp4")
    final_mp4 = out
    subprocess.run(
        [
            "ffmpeg",
            "-y",
            "-f",
            "concat",
            "-safe",
            "0",
            "-i",
            listp,
            "-r",
            str(fps),
            "-pix_fmt",
            "yuv420p",
            raw_mp4,
        ],
        check=True,
    )
    # tanpa audio; user tetap dapat video
    subprocess.run(
        ["ffmpeg", "-y", "-i", raw_mp4, "-c:v", "copy", "-an", final_mp4], check=True
    )
    return final_mp4


def enqueue_ticket(kind: str, payload: dict) -> Optional[str]:
    """Invisible queue: user gak dikasih error; kita proses di belakang."""
    if not (QUEUE_ON and _r):
        return None
    tid = f"{kind}:{int(time.time())}:{_sha(json.dumps(payload)[:256])}"
    job = {"tid": tid, "kind": kind, "payload": payload, "ts": int(time.time())}
    _r.lpush("jobs:deferred", json.dumps(job))
    _r.hset("jobs:status", tid, "queued")
    return tid


def ticket_status(tid: str) -> str:
    if not _r:
        return "unknown"
    v = _r.hget("jobs:status", tid)
    return v.decode() if v else "unknown"
