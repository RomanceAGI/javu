from __future__ import annotations
import os, json, time, traceback, subprocess, uuid, difflib
from typing import Dict, Any, Optional, List


class SelfRepairManager:
    """
    Menangkap exception runtime â†’ tulis incident + repro test + minta router LLM bikin patch.
    Tidak auto-apply kecuali SELF_REPAIR_APPLY=1 (fail-safe default: review dulu).
    Patch disimpan ke artifacts/patches/*.diff + PR via GitHub (opsional).
    """

    def __init__(self, project_root: str = ".", patches_dir: str = "artifacts/patches"):
        self.root = project_root
        self.patches = patches_dir
        os.makedirs(self.patches, exist_ok=True)

    def _ts(self) -> str:
        return time.strftime("%Y%m%d_%H%M%S", time.localtime())

    def on_exception(
        self, err: Exception, trace_id: str, context: Dict[str, Any] | None = None
    ) -> Dict[str, Any]:
        ctx = context or {}
        tb = traceback.format_exc()
        rid = f"{self._ts()}_{uuid.uuid4().hex[:8]}"
        incident = {
            "rid": rid,
            "trace": trace_id,
            "error": str(err),
            "tb": tb[:20000],
            "context": ctx,
            "ts": int(time.time()),
        }
        # log incident lokal untuk audit
        os.makedirs("artifacts/incidents", exist_ok=True)
        with open(f"artifacts/incidents/self_repair.jsonl", "a", encoding="utf-8") as f:
            f.write(json.dumps(incident, ensure_ascii=False) + "\n")

        # 1) buat repro test minimal (pytest)
        test_dir = "tests/regressions"
        os.makedirs(test_dir, exist_ok=True)
        test_path = os.path.join(test_dir, f"test_{rid}.py")
        # Build a minimal reproducible test.  Avoid backslashes in f-string expressions by
        # computing context and error strings ahead of time.
        context_str = json.dumps({k: str(v)[:200] for k, v in ctx.items()}, ensure_ascii=False)
        escaped_err = str(err).replace('"', '\\"')[:400]
        test_lines = [
            "# auto-generated by SelfRepairManager",
            f"def test_repro_{rid.replace('-', '_')}():",
            "    # TODO: isi ulang dengan input yang memicu error ini",
            "    # konteks ringkas:",
            f"    # {context_str}",
            f"    assert False, \"Repro placeholder for {trace_id}: {escaped_err}\"",
        ]
        test_body = "\n".join(test_lines) + "\n"
        with open(test_path, "w", encoding="utf-8") as f:
            f.write(test_body)

        # 2) minta router LLM usul patch (opsional: butuh llm_router)
        patch_file = os.path.join(self.patches, f"patch_{rid}.diff")
        try:
            from javu_agi.llm_router import route

            prompt = self._build_patch_prompt(err, tb, ctx)
            resp = route("code_patch", {"prompt": prompt})
            suggestion = (resp.get("text") or resp.get("patch") or "").strip()
            if suggestion:
                with open(patch_file, "w", encoding="utf-8") as f:
                    f.write(suggestion)
        except Exception:
            # fallback: diff kosong agar tidak gagal
            with open(patch_file, "w", encoding="utf-8") as f:
                f.write("# no patch suggestion\n")

        # 3) opsional: auto-apply patch
        applied = False
        apply_err = ""
        if os.getenv("SELF_REPAIR_APPLY", "0") == "1":
            try:
                applied = self._apply_patch(patch_file)
            except Exception as e:
                apply_err = str(e)

        # 4) jalankan pytest smoke (tidak blok kalau gagal)
        try:
            subprocess.run(
                ["pytest", "-q", "-k", rid], cwd=self.root, timeout=90, check=False
            )
        except Exception:
            pass

        return {
            "status": "ok",
            "rid": rid,
            "patch_file": patch_file,
            "applied": applied,
            "apply_err": apply_err,
        }

    def _apply_patch(self, patch_path: str) -> bool:
        if not os.path.exists(patch_path):
            return False
        # prefer 'git apply' kalau repo git
        if os.path.isdir(os.path.join(self.root, ".git")):
            r = subprocess.run(["git", "apply", patch_path], cwd=self.root, timeout=20)
            return r.returncode == 0
        # fallback naive (hanya komentar: implementasi real sebaiknya pakai git)
        return False

    def _build_patch_prompt(self, err: Exception, tb: str, ctx: Dict[str, Any]) -> str:
        return f"""
Anda adalah AGI perbaikan kode. Analisis error dan sarankan patch unified diff.
- Patch harus minimal & aman.
- Tambahkan unit test di tests/regressions/ yang membuktikan bug fixed.

ERROR:
{str(err)}

TRACEBACK:
{tb[:8000]}

CONTEXT (ringkas):
{json.dumps(ctx, ensure_ascii=False)[:4000]}

Keluarkan patch dalam format unified diff (git diff), tanpa penjelasan lain.
"""
